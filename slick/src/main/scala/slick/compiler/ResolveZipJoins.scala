package slick.compiler

import slick.ast._
import Util._
import TypeUtil._

/** Rewrite zip joins into a form suitable for SQL (using inner joins and
  * RowNumber columns.
  * We rely on having a Bind around every Join and both of its generators,
  * which should have been generated by Phase.forceOuterBinds. The inner
  * Binds need to select Pure(StructNode(...)) which should be the outcome
  * of Phase.flattenProjections. */
class ResolveZipJoins extends Phase {
  type State = Boolean
  val name = "resolveZipJoins"

  def apply(state: CompilerState) = {
    val n2 = resolveZipJoins(state.tree)
    state + (this -> (n2 ne state.tree)) withNode n2
  }

  def resolveZipJoins(n: Node): Node = (n match {
    // zip with index
    case Bind(oldBindSym, Join(_, _,
        l @ Bind(lsym, lfrom, Pure(StructNode(lstruct), _)),
        RangeFrom(offset),
        JoinType.Zip, LiteralNode(true)), Pure(sel, _)) =>
      val idxSym = new AnonSymbol
      val idxExpr =
        if(offset == 1L) RowNumber()
        else Library.-.typed[Long](RowNumber(), LiteralNode(1L - offset))
      val innerBind = Bind(lsym, lfrom, Pure(StructNode(lstruct :+ (idxSym, idxExpr)))).infer()
      val bindSym = new AnonSymbol
      val OldBindRef = Ref(oldBindSym)
      val bindRef = Ref(bindSym) :@ innerBind.nodeType.asCollectionType.elementType
      val newOuterSel = sel.replace {
        case Select(OldBindRef, ElementSymbol(1)) => bindRef
        case Select(OldBindRef, ElementSymbol(2)) => Select(bindRef, idxSym).infer()
      }
      Bind(bindSym, innerBind, Pure(newOuterSel)).infer(SymbolScope.empty, false, true)

    // zip with another query
    case b @ Bind(_, Join(jlsym, jrsym,
        l @ Bind(lsym, lfrom, Pure(StructNode(lstruct), ts1)),
        r @ Bind(rsym, rfrom, Pure(StructNode(rstruct), ts2)),
        JoinType.Zip, LiteralNode(true)), _) =>
      val lIdxSym, rIdxSym = new AnonSymbol
      val lInnerBind = Bind(lsym, lfrom, Pure(StructNode(lstruct :+ (lIdxSym, RowNumber())), ts1)).infer(retype = true)
      val rInnerBind = Bind(rsym, rfrom, Pure(StructNode(rstruct :+ (rIdxSym, RowNumber())), ts2)).infer(retype = true)
      val jlRef = Ref(jlsym) :@ lInnerBind.nodeType.asCollectionType.elementType
      val jrRef = Ref(jrsym) :@ rInnerBind.nodeType.asCollectionType.elementType
      val join = Join(jlsym, jrsym, lInnerBind, rInnerBind, JoinType.Inner,
        Library.==.typed[Boolean](Select(jlRef, lIdxSym).infer(), Select(jrRef, rIdxSym).infer())
      )
      b.copy(from = join)

    case n => n
  }).mapChildren(resolveZipJoins, keepType = true)
}
